<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>parquet2 - parquet2 documentation</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html" class="active"><strong aria-hidden="true">1.</strong> parquet2</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">parquet2 documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parquet2"><a class="header" href="#parquet2">Parquet2</a></h1>
<p>Parquet2 is a rust library to interact with the
<a href="https://en.wikipedia.org/wiki/Apache_Parquet">parquet format</a>, welcome to its guide!</p>
<p>This guide describes on how to efficiently and safely read and write
to and from parquet.
Before starting, there are two concepts to introduce in the context of this guide:</p>
<ul>
<li>IO-bound operations: perform either disk reads or network calls (e.g. s3)</li>
<li>CPU-bound operations: perform compute</li>
</ul>
<p>In this guide, &quot;read&quot;, &quot;write&quot; and &quot;seek&quot; correspond to
IO-bound operations, &quot;decompress&quot;, &quot;compress&quot;, &quot;deserialize&quot;, etc. are CPU-bound.</p>
<p>Generally, IO-bound operations are parallelizable with green threads, while CPU-bound
operations are not. </p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>The starting point of reading a parquet file is reading its
metadata (at the end of the file).
To do so, we offer two functions for <code>sync</code> and <code>async</code>:</p>
<h4 id="sync"><a class="header" href="#sync">Sync</a></h4>
<p><code>parquet2::read::read_metadata</code> for <code>sync</code> reads:</p>
<pre><code class="language-rust no_run noplayground">    use std::env;
    let args: Vec&lt;String&gt; = env::args().collect();

    let path = &amp;args[1];

    use parquet2::read::read_metadata;
    let mut reader = std::fs::File::open(path)?;
    let metadata = read_metadata(&amp;mut reader)?;

    println!(&quot;{:#?}&quot;, metadata);
</code></pre>
<h4 id="async"><a class="header" href="#async">Async</a></h4>
<p>and <code>parquet2::read::read_metadata_async</code>, for async reads
(using <code>tokio::fs</code> as example):</p>
<pre><pre class="playground"><code class="language-rust">use async_compat::Compat;
use parquet2::{error::Result, read::read_metadata_async};
use tokio::fs;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let mut reader = Compat::new(fs::File::open(&quot;path.parquet&quot;).await?);
    let metadata = read_metadata_async(&amp;mut reader).await?;

    // metadata
    println!(&quot;{:#?}&quot;, metadata);
    Ok(())
}
</code></pre></pre>
<p>In both cases, <code>metadata: FileMetaData</code> is the file's metadata.</p>
<h2 id="columns-row-groups-columns-chunks-and-pages"><a class="header" href="#columns-row-groups-columns-chunks-and-pages">Columns, Row Groups, Columns chunks and Pages</a></h2>
<p>At this point, it is important to give a small introduction to the format itself.
The metadata does not contain any data. Instead, the metadata contains
the necessary information to read, decompress, decode and deserialize data. Generally:</p>
<ul>
<li>a file has a schema with columns and data</li>
<li>data in the file is divided in <em>row groups</em></li>
<li>each <em>row group</em> contains <em>column chunks</em></li>
<li>each <em>column chunk</em> contains <em>pages</em></li>
<li>each <em>page</em> contains multiple values</li>
</ul>
<p>each of the entities above has associated metadata. Except for the pages,
all this metadata is already available in the <code>FileMetaData</code>.
Here we will focus on a single column to show how we can read it.</p>
<p>We access the metadata of a column chunk via</p>
<pre><code class="language-rust no_run noplayground">    let row_group = 0;
    let column = 0;
    let columns = metadata.row_groups[row_group].columns();
    let column_metadata = &amp;columns[column];
</code></pre>
<p>From this, we can produce an iterator of compressed pages (sync), 
<code>parquet2::read::get_page_iterator</code> or a stream (async) of compressed
pages, <code>parquet2::read::get_page_stream</code>:</p>
<pre><code class="language-rust no_run noplayground">    use parquet2::read::get_page_iterator;
    let pages = get_page_iterator(column_metadata, &amp;mut reader, None, vec![], 1024 * 1024)?;
</code></pre>
<p>in both cases, they yield individual <code>CompressedDataPage</code>s. Note that these
pages do hold values and own potentially large chunks of (compressed) memory.</p>
<p>At this point, we are missing 3 steps: decompress, decode and deserialize.
Decompression is done via <code>decompress</code>:</p>
<pre><code class="language-rust no_run noplayground">    let mut decompress_buffer = vec![];
    let mut dict = None;
    for maybe_page in pages {
        let page = maybe_page?;
        let page = parquet2::read::decompress(page, &amp;mut decompress_buffer)?;

        match page {
            Page::Dict(page) =&gt; {
                // the first page may be a dictionary page, which needs to be deserialized
                // depending on your target in-memory format, you may want to deserialize
                // the values differently...
                // let page = deserialize_dict(&amp;page)?;
                dict = Some(page);
            }
            Page::Data(page) =&gt; {
                let _array = deserialize(&amp;page, dict.as_ref())?;
            }
        }
    }
</code></pre>
<p>Decoding and deserialization is usually done in the same step, as follows:</p>
<pre><code class="language-rust no_run noplayground">use parquet2::encoding::Encoding;
use parquet2::page::{split_buffer, DataPage, DictPage, Page};
use parquet2::schema::types::PhysicalType;

fn deserialize(page: &amp;DataPage, dict: Option&lt;&amp;DictPage&gt;) -&gt; Result&lt;()&gt; {
    // split the data buffer in repetition levels, definition levels and values
    let (_rep_levels, _def_levels, _values_buffer) = split_buffer(page)?;

    // decode and deserialize.
    match (
        page.descriptor.primitive_type.physical_type,
        page.encoding(),
        dict,
    ) {
        (
            PhysicalType::Int32,
            Encoding::PlainDictionary | Encoding::RleDictionary,
            Some(_dict_page),
        ) =&gt; {
            // plain encoded page with a dictionary
            // _dict_page can be downcasted based on the descriptor's physical type
            todo!()
        }
        (PhysicalType::Int32, Encoding::Plain, None) =&gt; {
            // plain encoded page
            todo!()
        }
        _ =&gt; todo!(),
    }
}
</code></pre>
<p>the details of the <code>todo!</code> are highly specific to the target in-memory format to use.
Thus, here we only describe how to decompose the page buffer in its individual
components and what you need to worry about.
For example, reading to Apache Arrow often does not require decoding the
definition levels, as they have the same representation as in Arrow, but do require
deserialization of some values, as e.g. arrow supports unsigned integers while
parquet only accepts (potentially encoded) <code>i32</code> and <code>i64</code> integers.
Refer to the integration tests's implementation for deserialization to a 
simple in-memory format, and <a href="https://github.com/jorgecarleitao/arrow2">arrow2</a>
for an implementation to the Apache Arrow format.</p>
<h2 id="row-group-statistics"><a class="header" href="#row-group-statistics">Row group statistics</a></h2>
<p>The metadata of row groups can contain row group statistics that
can be used to pushdown filter operations.</p>
<p>The statistics are encoded based on the physical type of the column and
are represented via trait objects of the trait <code>Statistics</code>,
which can be downcasted via its <code>Statistics::physical_type()</code>:</p>
<pre><code class="language-rust no_run noplayground">    if let Some(maybe_stats) = column_metadata.statistics() {
        let stats = maybe_stats?;
        use parquet2::statistics::PrimitiveStatistics;
        match stats.physical_type() {
            PhysicalType::Int32 =&gt; {
                let stats = stats
                    .as_any()
                    .downcast_ref::&lt;PrimitiveStatistics&lt;i32&gt;&gt;()
                    .unwrap();
                let _min: i32 = stats.min_value.unwrap();
                let _max: i32 = stats.max_value.unwrap();
                let _null_count: i64 = stats.null_count.unwrap();
            }
            PhysicalType::Int64 =&gt; {
                let stats = stats
                    .as_any()
                    .downcast_ref::&lt;PrimitiveStatistics&lt;i64&gt;&gt;()
                    .unwrap();
                let _min: i64 = stats.min_value.unwrap();
                let _max: i64 = stats.max_value.unwrap();
                let _null_count: i64 = stats.null_count.unwrap();
            }
            _ =&gt; todo!(),
        }
    }
</code></pre>
<h2 id="bloom-filters"><a class="header" href="#bloom-filters">Bloom filters</a></h2>
<p>The column metadata may contain bloom filter bitsets that can be used to pushdown
filter operations to row groups.</p>
<p>This crate offers the necessary functionality to check whether an item is not in a column chunk:</p>
<pre><code class="language-rust no_run noplayground">    let mut bitset = vec![];
    bloom_filter::read(column_metadata, &amp;mut reader, &amp;mut bitset)?;
    if !bitset.is_empty() {
        // there is a bitset, we can use it to check if elements are in the column chunk

        // assume that our query engine had resulted in the filter `&quot;column 0&quot; == 100i64` (it also verified that column 0 is i64 in parquet)
        let value = 100i64;

        // we hash this value
        let hash = bloom_filter::hash_native(value);

        // and check if the hash is in the bitset.
        let _in_set = bloom_filter::is_in_set(&amp;bitset, hash);
        // if not (false), we could skip this entire row group, because no item hits the filter
        // this can naturally be applied over multiple columns.
        // if yes (true), the item _may_ be in the row group, and we usually can't skip it.
    }
</code></pre>
<h2 id="column-and-page-indexes"><a class="header" href="#column-and-page-indexes">Column and page indexes</a></h2>
<p>The column metadata may contain column and page indexes that can be used to push down filters
when reading (IO) pages.</p>
<p>This crate offers the necessary functionality to check whether an item is not in a column chunk:</p>
<pre><code class="language-rust no_run noplayground">    // read the column indexes of every column
    use parquet2::read;
    let index = read::read_columns_indexes(&amp;mut reader, columns)?;
    // these are the minimum and maximum within each page, which can be used
    // to skip pages.
    println!(&quot;{index:?}&quot;);

    // read the offset indexes containing page locations of every column
    let pages = read::read_pages_locations(&amp;mut reader, columns)?;
    println!(&quot;{pages:?}&quot;);
</code></pre>
<h2 id="sidecar"><a class="header" href="#sidecar">Sidecar</a></h2>
<p>When writing multiple parquet files, it is common to have a &quot;sidecar&quot; metadata file containing
the combined metadata of all files, including statistics.</p>
<p>This crate supports this use-case, as shown in the example below:</p>
<pre><pre class="playground"><code class="language-rust">use parquet2::{
    error::Error,
    metadata::SchemaDescriptor,
    schema::types::{ParquetType, PhysicalType},
    write::{write_metadata_sidecar, FileWriter, Version, WriteOptions},
};

fn main() -&gt; Result&lt;(), Error&gt; {
    // say we have 10 files with the same schema:
    let schema = SchemaDescriptor::new(
        &quot;schema&quot;.to_string(),
        vec![ParquetType::from_physical(
            &quot;c1&quot;.to_string(),
            PhysicalType::Int32,
        )],
    );

    // we can collect their metadata after they are written
    let mut metadatas = vec![];
    for i in 0..10 {
        let relative_path = format!(&quot;part-{i}.parquet&quot;);
        let writer = std::io::Cursor::new(vec![]);
        let mut writer = FileWriter::new(
            writer,
            schema.clone(),
            WriteOptions {
                write_statistics: true,
                version: Version::V2,
            },
            None,
        );

        // we write row groups to it
        // writer.write(row_group)

        // and the footer
        writer.end(None)?;
        let (_, mut metadata) = writer.into_inner_and_metadata();

        // once done, we write the relative path to the column chunks
        metadata.row_groups.iter_mut().for_each(|row_group| {
            row_group
                .columns
                .iter_mut()
                .for_each(|column| column.file_path = Some(relative_path.clone()))
        });
        // and collect the metadata
        metadatas.push(metadata);
    }

    // we can then merge their row groups
    let first = metadatas.pop().unwrap();
    let sidecar = metadatas.into_iter().fold(first, |mut acc, metadata| {
        acc.row_groups.extend(metadata.row_groups.into_iter());
        acc
    });

    // and write the metadata on a separate file
    let mut writer = std::io::Cursor::new(vec![]);
    write_metadata_sidecar(&amp;mut writer, &amp;sidecar)?;

    Ok(())
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
